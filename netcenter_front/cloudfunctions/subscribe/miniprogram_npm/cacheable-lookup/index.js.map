{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst {Resolver, V4MAPPED, ADDRCONFIG} = require('dns');\nconst {promisify} = require('util');\nconst os = require('os');\nconst Keyv = require('keyv');\n\nconst map4to6 = entries => {\n\tfor (const entry of entries) {\n\t\tentry.address = `::ffff:${entry.address}`;\n\t\tentry.family = 6;\n\t}\n};\n\nconst getIfaceInfo = () => {\n\tlet has4 = false;\n\tlet has6 = false;\n\n\tfor (const device of Object.values(os.networkInterfaces())) {\n\t\tfor (const iface of device) {\n\t\t\tif (iface.internal) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iface.family === 'IPv6') {\n\t\t\t\thas6 = true;\n\t\t\t} else {\n\t\t\t\thas4 = true;\n\t\t\t}\n\n\t\t\tif (has4 && has6) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {has4, has6};\n};\n\nclass CacheableLookup {\n\tconstructor(options = {}) {\n\t\tconst {cacheAdapter} = options;\n\t\tthis.cache = new Keyv({\n\t\t\turi: typeof cacheAdapter === 'string' && cacheAdapter,\n\t\t\tstore: typeof cacheAdapter !== 'string' && cacheAdapter,\n\t\t\tnamespace: 'cached-lookup'\n\t\t});\n\n\t\tthis.maxTtl = options.maxTtl === 0 ? 0 : (options.maxTtl || Infinity);\n\n\t\tthis._resolver = options.resolver || new Resolver();\n\t\tthis._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n\t\tthis._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n\n\t\tthis.lookup = this.lookup.bind(this);\n\t\tthis.lookupAsync = this.lookupAsync.bind(this);\n\t}\n\n\tset servers(servers) {\n\t\tthis._resolver.setServers(servers);\n\t}\n\n\tget servers() {\n\t\treturn this._resolver.getServers();\n\t}\n\n\tlookup(hostname, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\tthis.lookupAsync(hostname, {...options, throwNotFound: true}).then(result => {\n\t\t\tif (options.all) {\n\t\t\t\tcallback(null, result);\n\t\t\t} else {\n\t\t\t\tcallback(null, result.address, result.family);\n\t\t\t}\n\t\t}).catch(callback);\n\t}\n\n\tasync lookupAsync(hostname, options = {}) {\n\t\tlet cached;\n\t\tif (!options.family && options.all) {\n\t\t\tconst [cached4, cached6] = await Promise.all([this.lookupAsync(hostname, {all: true, family: 4, details: true}), this.lookupAsync(hostname, {all: true, family: 6, details: true})]);\n\t\t\tcached = [...cached4, ...cached6];\n\t\t} else {\n\t\t\tcached = await this.query(hostname, options.family || 4);\n\n\t\t\tif (cached.length === 0 && options.family === 6 && options.hints & V4MAPPED) {\n\t\t\t\tcached = await this.query(hostname, 4);\n\t\t\t\tmap4to6(cached);\n\t\t\t}\n\t\t}\n\n\t\tif (options.hints & ADDRCONFIG) {\n\t\t\tconst {has4, has6} = getIfaceInfo();\n\t\t\tcached = cached.filter(entry => entry.family === 6 ? has6 : has4);\n\t\t}\n\n\t\tif (options.throwNotFound && cached.length === 0) {\n\t\t\tconst error = new Error(`ENOTFOUND ${hostname}`);\n\t\t\terror.code = 'ENOTFOUND';\n\t\t\terror.hostname = hostname;\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\tcached = cached.filter(entry => !Reflect.has(entry, 'expires') || now < entry.expires);\n\n\t\tif (!options.details) {\n\t\t\tcached = cached.map(entry => {\n\t\t\t\treturn {\n\t\t\t\t\taddress: entry.address,\n\t\t\t\t\tfamily: entry.family\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tif (options.all) {\n\t\t\treturn cached;\n\t\t}\n\n\t\tif (cached.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._getEntry(cached);\n\t}\n\n\tasync query(hostname, family) {\n\t\tlet cached = await this.cache.get(`${hostname}:${family}`);\n\t\tif (!cached) {\n\t\t\tcached = await this.queryAndCache(hostname, family);\n\t\t}\n\n\t\treturn cached;\n\t}\n\n\tasync queryAndCache(hostname, family) {\n\t\tconst resolve = family === 4 ? this._resolve4 : this._resolve6;\n\t\tconst entries = await resolve(hostname, {ttl: true});\n\n\t\tif (entries === undefined) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst now = Date.now();\n\n\t\tlet cacheTtl = 0;\n\t\tfor (const entry of entries) {\n\t\t\tcacheTtl = Math.max(cacheTtl, entry.ttl);\n\t\t\tentry.family = family;\n\n\t\t\tif (entry.ttl !== 0) {\n\t\t\t\tentry.expires = now + (entry.ttl * 1000);\n\t\t\t}\n\t\t}\n\n\t\tcacheTtl = Math.min(this.maxTtl, cacheTtl) * 1000;\n\n\t\tif (this.maxTtl !== 0 && cacheTtl !== 0) {\n\t\t\tawait this.cache.set(`${hostname}:${family}`, entries, cacheTtl);\n\t\t}\n\n\t\treturn entries;\n\t}\n\n\t_getEntry(entries) {\n\t\treturn entries[Math.floor(Math.random() * entries.length)];\n\t}\n}\n\nmodule.exports = CacheableLookup;\nmodule.exports.default = CacheableLookup;\n"]}