{"version":3,"sources":["index.js","create.js","as-promise.js","errors.js","normalize-arguments.js","known-hook-events.js","utils/dynamic-require.js","utils/get-body-size.js","utils/is-form-data.js","utils/merge.js","utils/options-to-url.js","utils/supports-brotli.js","request-as-event-emitter.js","calculate-retry-delay.js","get-response.js","progress.js","utils/timed-out.js","utils/unhandle.js","utils/url-to-options.js","as-stream.js","utils/deep-freeze.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA,AIZA;AFOA,ADGA,AENA,AHSA,AIZA;AFOA,ADGA,AENA,AHSA,AIZA;AFOA,ADGA,AENA,AHSA,AKfA,ADGA;AFOA,ADGA,AENA,AHSA,AKfA,ADGA;AFOA,ADGA,AENA,AHSA,AKfA,ADGA;AFOA,ADGA,AENA,AHSA,AKfA,ADGA,AENA;AJaA,ADGA,AENA,AHSA,AKfA,ADGA,AENA;AJaA,ADGA,AENA,AHSA,AKfA,ADGA,AENA;AJaA,ADGA,AENA,AHSA,AKfA,ADGA,AENA,ACHA;ALgBA,ADGA,AENA,AHSA,AKfA,ADGA,AENA,ACHA;ALgBA,ADGA,AENA,AHSA,AKfA,ADGA,AGTA;ALgBA,ADGA,AENA,AHSA,AKfA,ADGA,AGTA,ACHA;ANmBA,ADGA,AENA,AHSA,AKfA,ADGA,AGTA,ACHA;ANmBA,ADGA,AENA,AHSA,AKfA,ADGA,AGTA,ACHA;ANmBA,ADGA,AENA,AHSA,AIZA,AGTA,ACHA,ACHA;APsBA,ADGA,AENA,AHSA,AIZA,AGTA,ACHA,ACHA;APsBA,ADGA,AENA,AHSA,AIZA,AGTA,AENA;APsBA,ADGA,AENA,AHSA,AIZA,AGTA,AENA,ACHA;ARyBA,ADGA,AENA,AHSA,AIZA,AGTA,AENA,ACHA;ARyBA,ADGA,AENA,AHSA,AIZA,AGTA,AENA,ACHA;ARyBA,ADGA,AENA,AHSA,AIZA,AGTA,AENA,ACHA,ACHA;AT4BA,ADGA,AENA,AHSA,AIZA,AGTA,AENA,ACHA,ACHA;AT4BA,ADGA,AENA,AHSA,AIZA,AGTA,AENA,ACHA,ACHA;AT4BA,ADGA,AENA,AHSA,AIZA,AQxBA,ALeA,AENA,ACHA,ACHA;AT4BA,ADGA,AENA,AHSA,AIZA,AQxBA,ALeA,AENA,ACHA,ACHA;AT4BA,ADGA,AENA,AHSA,AIZA,AQxBA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AHSA,AIZA,AQxBA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AHSA,AIZA,AQxBA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AHSA,AIZA,AQxBA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AQxBA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AQxBA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AQxBA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,ALeA,AENA,ACHA;ARyBA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,ALeA,AENA,ACHA,AMlBA;Ad2CA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,ALeA,AENA,ACHA,AMlBA;Ad2CA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,ALeA,AENA,ACHA,AMlBA;Ad2CA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,ALeA,AENA,ACHA,AMlBA,ACHA;Af8CA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AHSA,ACHA,AMlBA,ACHA;Af8CA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AHSA,ACHA,AMlBA,ACHA;Af8CA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AHSA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AHSA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AWjCA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AHSA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AHSA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AHSA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AHSA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AQxBA,AXiCA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AQxBA,AXiCA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AQxBA,AXiCA,ACHA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AWjCA,Ad0CA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AQxBA,AV8BA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA,ACHA,ACHA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA,AENA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA,AENA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA,AENA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA,AENA;AhBiDA,AiBnDA,ANkBA,AZoCA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA,AENA;AhBiDA,AiBnDA,AlBsDA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,AHSA,AIZA,AWjCA,AHSA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AlBsDA,AENA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AFMA,AMlBA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,AhBgDA,ACHA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;Ad2CA,AiBnDA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AGRA,Af6CA,AQxBA,AIZA;AZqCA,AQxBA,AIZA;AZqCA,AQxBA,AIZA;AZqCA,AQxBA,AIZA;AZqCA,AQxBA,AIZA;AZqCA,AQxBA,AIZA;AZqCA,AQxBA,AIZA;AZqCA,AQxBA,AIZA;AZqCA,AQxBA,AIZA;AZqCA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA,AQxBA;ARyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst create_1 = require(\"./create\");\nconst defaults = {\n    options: {\n        method: 'GET',\n        retry: {\n            limit: 2,\n            methods: [\n                'GET',\n                'PUT',\n                'HEAD',\n                'DELETE',\n                'OPTIONS',\n                'TRACE'\n            ],\n            statusCodes: [\n                408,\n                413,\n                429,\n                500,\n                502,\n                503,\n                504\n            ],\n            errorCodes: [\n                'ETIMEDOUT',\n                'ECONNRESET',\n                'EADDRINUSE',\n                'ECONNREFUSED',\n                'EPIPE',\n                'ENOTFOUND',\n                'ENETUNREACH',\n                'EAI_AGAIN'\n            ],\n            maxRetryAfter: undefined,\n            calculateDelay: ({ computedValue }) => computedValue\n        },\n        timeout: {},\n        headers: {\n            'user-agent': 'got (https://github.com/sindresorhus/got)'\n        },\n        hooks: {\n            init: [],\n            beforeRequest: [],\n            beforeRedirect: [],\n            beforeRetry: [],\n            beforeError: [],\n            afterResponse: []\n        },\n        decompress: true,\n        throwHttpErrors: true,\n        followRedirect: true,\n        isStream: false,\n        cache: false,\n        dnsCache: false,\n        useElectronNet: false,\n        responseType: 'text',\n        resolveBodyOnly: false,\n        maxRedirects: 10,\n        prefixUrl: '',\n        methodRewriting: true,\n        ignoreInvalidCookies: false,\n        context: {}\n    },\n    handlers: [create_1.defaultHandler],\n    mutableDefaults: false\n};\nconst got = create_1.default(defaults);\nexports.default = got;\n// For CommonJS default export support\nmodule.exports = got;\nmodule.exports.default = got;\nvar as_stream_1 = require(\"./as-stream\");\nexports.ResponseStream = as_stream_1.ProxyStream;\nvar errors_1 = require(\"./errors\");\nexports.GotError = errors_1.GotError;\nexports.CacheError = errors_1.CacheError;\nexports.RequestError = errors_1.RequestError;\nexports.ParseError = errors_1.ParseError;\nexports.HTTPError = errors_1.HTTPError;\nexports.MaxRedirectsError = errors_1.MaxRedirectsError;\nexports.UnsupportedProtocolError = errors_1.UnsupportedProtocolError;\nexports.TimeoutError = errors_1.TimeoutError;\nexports.CancelError = errors_1.CancelError;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst as_promise_1 = require(\"./as-promise\");\nconst as_stream_1 = require(\"./as-stream\");\nconst errors = require(\"./errors\");\nconst normalize_arguments_1 = require(\"./normalize-arguments\");\nconst deep_freeze_1 = require(\"./utils/deep-freeze\");\nconst getPromiseOrStream = (options) => options.isStream ? as_stream_1.default(options) : as_promise_1.default(options);\nconst isGotInstance = (value) => (Reflect.has(value, 'defaults') && Reflect.has(value.defaults, 'options'));\nconst aliases = [\n    'get',\n    'post',\n    'put',\n    'patch',\n    'head',\n    'delete'\n];\nexports.defaultHandler = (options, next) => next(options);\nconst create = (defaults) => {\n    // Proxy properties from next handlers\n    // @ts-ignore Internal use only.\n    defaults._rawHandlers = defaults.handlers;\n    defaults.handlers = defaults.handlers.map(fn => ((options, next) => {\n        // This will be assigned by assigning result\n        let root;\n        const result = fn(options, newOptions => {\n            root = next(newOptions);\n            return root;\n        });\n        if (result !== root && !options.isStream) {\n            Object.setPrototypeOf(result, Object.getPrototypeOf(root));\n            Object.defineProperties(result, Object.getOwnPropertyDescriptors(root));\n        }\n        return result;\n    }));\n    // @ts-ignore Because the for loop handles it for us, as well as the other Object.defines\n    const got = (url, options) => {\n        var _a;\n        let iteration = 0;\n        const iterateHandlers = (newOptions) => {\n            return defaults.handlers[iteration++](newOptions, \n            // @ts-ignore TS doesn't know that it calls `getPromiseOrStream` at the end\n            iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);\n        };\n        /* eslint-disable @typescript-eslint/return-await */\n        try {\n            return iterateHandlers(normalize_arguments_1.normalizeArguments(url, options, defaults));\n        }\n        catch (error) {\n            if ((_a = options) === null || _a === void 0 ? void 0 : _a.isStream) {\n                throw error;\n            }\n            else {\n                // @ts-ignore It's an Error not a response, but TS thinks it's calling .resolve\n                return Promise.reject(error);\n            }\n        }\n        /* eslint-enable @typescript-eslint/return-await */\n    };\n    got.extend = (...instancesOrOptions) => {\n        const optionsArray = [defaults.options];\n        // @ts-ignore Internal use only.\n        let handlers = [...defaults._rawHandlers];\n        let mutableDefaults;\n        for (const value of instancesOrOptions) {\n            if (isGotInstance(value)) {\n                optionsArray.push(value.defaults.options);\n                // @ts-ignore Internal use only.\n                handlers.push(...value.defaults._rawHandlers);\n                mutableDefaults = value.defaults.mutableDefaults;\n            }\n            else {\n                optionsArray.push(value);\n                if (Reflect.has(value, 'handlers')) {\n                    handlers.push(...value.handlers);\n                }\n                mutableDefaults = value.mutableDefaults;\n            }\n        }\n        handlers = handlers.filter(handler => handler !== exports.defaultHandler);\n        if (handlers.length === 0) {\n            handlers.push(exports.defaultHandler);\n        }\n        return create({\n            options: normalize_arguments_1.mergeOptions(...optionsArray),\n            handlers,\n            mutableDefaults: Boolean(mutableDefaults)\n        });\n    };\n    // @ts-ignore The missing methods because the for-loop handles it for us\n    got.stream = (url, options) => got(url, { ...options, isStream: true });\n    for (const method of aliases) {\n        // @ts-ignore GotReturn<Response> does not equal GotReturn<T>\n        got[method] = (url, options) => got(url, { ...options, method });\n        got.stream[method] = (url, options) => got.stream(url, { ...options, method });\n    }\n    Object.assign(got, { ...errors, mergeOptions: normalize_arguments_1.mergeOptions });\n    Object.defineProperty(got, 'defaults', {\n        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),\n        writable: defaults.mutableDefaults,\n        configurable: defaults.mutableDefaults,\n        enumerable: true\n    });\n    return got;\n};\nexports.default = create;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"events\");\nconst getStream = require(\"get-stream\");\nconst PCancelable = require(\"p-cancelable\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst errors_1 = require(\"./errors\");\nconst normalize_arguments_1 = require(\"./normalize-arguments\");\nconst request_as_event_emitter_1 = require(\"./request-as-event-emitter\");\nconst parseBody = (body, responseType, encoding) => {\n    if (responseType === 'json') {\n        return body.length === 0 ? '' : JSON.parse(body.toString());\n    }\n    if (responseType === 'buffer') {\n        return Buffer.from(body);\n    }\n    if (responseType === 'text') {\n        return body.toString(encoding);\n    }\n    throw new TypeError(`Unknown body type '${responseType}'`);\n};\nfunction asPromise(options) {\n    const proxy = new EventEmitter();\n    let body;\n    // @ts-ignore `.json()`, `.buffer()` and `.text()` are added later\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        const emitter = request_as_event_emitter_1.default(options);\n        onCancel(emitter.abort);\n        const emitError = async (error) => {\n            try {\n                for (const hook of options.hooks.beforeError) {\n                    // eslint-disable-next-line no-await-in-loop\n                    error = await hook(error);\n                }\n                reject(error);\n            }\n            catch (error_) {\n                reject(error_);\n            }\n        };\n        emitter.on('response', async (response) => {\n            var _a;\n            proxy.emit('response', response);\n            // Download body\n            try {\n                body = await getStream.buffer(response, { encoding: 'binary' });\n            }\n            catch (error) {\n                emitError(new errors_1.ReadError(error, options));\n                return;\n            }\n            if ((_a = response.req) === null || _a === void 0 ? void 0 : _a.aborted) {\n                // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n                return;\n            }\n            const isOk = () => {\n                const { statusCode } = response;\n                const limitStatusCode = options.followRedirect ? 299 : 399;\n                return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;\n            };\n            // Parse body\n            try {\n                response.body = parseBody(body, options.responseType, options.encoding);\n            }\n            catch (error) {\n                if (isOk()) {\n                    const parseError = new errors_1.ParseError(error, response, options);\n                    emitError(parseError);\n                    return;\n                }\n                // Fall back to `utf8`\n                response.body = body.toString();\n            }\n            try {\n                for (const [index, hook] of options.hooks.afterResponse.entries()) {\n                    // @ts-ignore Promise is not assignable to CancelableRequest\n                    // eslint-disable-next-line no-await-in-loop\n                    response = await hook(response, async (updatedOptions) => {\n                        updatedOptions = normalize_arguments_1.normalizeArguments(normalize_arguments_1.mergeOptions(options, {\n                            ...updatedOptions,\n                            retry: {\n                                calculateDelay: () => 0\n                            },\n                            throwHttpErrors: false,\n                            resolveBodyOnly: false\n                        }));\n                        // Remove any further hooks for that request, because we'll call them anyway.\n                        // The loop continues. We don't want duplicates (asPromise recursion).\n                        updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n                        for (const hook of options.hooks.beforeRetry) {\n                            // eslint-disable-next-line no-await-in-loop\n                            await hook(updatedOptions);\n                        }\n                        const promise = asPromise(updatedOptions);\n                        onCancel(() => {\n                            promise.catch(() => { });\n                            promise.cancel();\n                        });\n                        return promise;\n                    });\n                }\n            }\n            catch (error) {\n                emitError(error);\n                return;\n            }\n            // Check for HTTP error codes\n            if (!isOk()) {\n                const error = new errors_1.HTTPError(response, options);\n                if (emitter.retry(error)) {\n                    return;\n                }\n                if (options.throwHttpErrors) {\n                    emitError(error);\n                    return;\n                }\n            }\n            resolve(options.resolveBodyOnly ? response.body : response);\n        });\n        emitter.once('error', reject);\n        request_as_event_emitter_1.proxyEvents(proxy, emitter);\n    });\n    promise.on = (name, fn) => {\n        proxy.on(name, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        // eslint-disable-next-line promise/prefer-await-to-then\n        const newPromise = promise.then(() => parseBody(body, responseType, options.encoding));\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        if (is_1.default.undefined(body) && is_1.default.undefined(options.headers.accept)) {\n            options.headers.accept = 'application/json';\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\nexports.default = asPromise;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst is_1 = require(\"@sindresorhus/is\");\nclass GotError extends Error {\n    constructor(message, error, options) {\n        super(message);\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stack\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, this.constructor);\n        this.name = 'GotError';\n        if (!is_1.default.undefined(error.code)) {\n            this.code = error.code;\n        }\n        Object.defineProperty(this, 'options', {\n            // This fails because of TS 3.7.2 useDefineForClassFields\n            // Ref: https://github.com/microsoft/TypeScript/issues/34972\n            enumerable: false,\n            value: options\n        });\n        // Recover the original stacktrace\n        if (!is_1.default.undefined(error.stack)) {\n            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;\n            const thisStackTrace = this.stack.slice(indexOfMessage).split('\\n').reverse();\n            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\\n').reverse();\n            // Remove duplicated traces\n            while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {\n                thisStackTrace.shift();\n            }\n            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\\n')}${errorStackTrace.reverse().join('\\n')}`;\n        }\n    }\n}\nexports.GotError = GotError;\nclass CacheError extends GotError {\n    constructor(error, options) {\n        super(error.message, error, options);\n        this.name = 'CacheError';\n    }\n}\nexports.CacheError = CacheError;\nclass RequestError extends GotError {\n    constructor(error, options) {\n        super(error.message, error, options);\n        this.name = 'RequestError';\n    }\n}\nexports.RequestError = RequestError;\nclass ReadError extends GotError {\n    constructor(error, options) {\n        super(error.message, error, options);\n        this.name = 'ReadError';\n    }\n}\nexports.ReadError = ReadError;\nclass ParseError extends GotError {\n    constructor(error, response, options) {\n        super(`${error.message} in \"${options.url.toString()}\"`, error, options);\n        this.name = 'ParseError';\n        Object.defineProperty(this, 'response', {\n            enumerable: false,\n            value: response\n        });\n    }\n}\nexports.ParseError = ParseError;\nclass HTTPError extends GotError {\n    constructor(response, options) {\n        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, options);\n        this.name = 'HTTPError';\n        Object.defineProperty(this, 'response', {\n            enumerable: false,\n            value: response\n        });\n    }\n}\nexports.HTTPError = HTTPError;\nclass MaxRedirectsError extends GotError {\n    constructor(response, maxRedirects, options) {\n        super(`Redirected ${maxRedirects} times. Aborting.`, {}, options);\n        this.name = 'MaxRedirectsError';\n        Object.defineProperty(this, 'response', {\n            enumerable: false,\n            value: response\n        });\n    }\n}\nexports.MaxRedirectsError = MaxRedirectsError;\nclass UnsupportedProtocolError extends GotError {\n    constructor(options) {\n        super(`Unsupported protocol \"${options.url.protocol}\"`, {}, options);\n        this.name = 'UnsupportedProtocolError';\n    }\n}\nexports.UnsupportedProtocolError = UnsupportedProtocolError;\nclass TimeoutError extends GotError {\n    constructor(error, timings, options) {\n        super(error.message, error, options);\n        Object.defineProperty(this, \"timings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"event\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = 'TimeoutError';\n        this.event = error.event;\n        this.timings = timings;\n    }\n}\nexports.TimeoutError = TimeoutError;\nvar p_cancelable_1 = require(\"p-cancelable\");\nexports.CancelError = p_cancelable_1.CancelError;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nconst util_1 = require(\"util\");\nconst CacheableRequest = require(\"cacheable-request\");\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst lowercaseKeys = require(\"lowercase-keys\");\nconst toReadableStream = require(\"to-readable-stream\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst cacheable_lookup_1 = require(\"cacheable-lookup\");\nconst errors_1 = require(\"./errors\");\nconst known_hook_events_1 = require(\"./known-hook-events\");\nconst dynamic_require_1 = require(\"./utils/dynamic-require\");\nconst get_body_size_1 = require(\"./utils/get-body-size\");\nconst is_form_data_1 = require(\"./utils/is-form-data\");\nconst merge_1 = require(\"./utils/merge\");\nconst options_to_url_1 = require(\"./utils/options-to-url\");\nconst supports_brotli_1 = require(\"./utils/supports-brotli\");\nconst nonEnumerableProperties = [\n    'context',\n    'body',\n    'json',\n    'form'\n];\nconst isAgentByProtocol = (agent) => is_1.default.object(agent);\n// TODO: `preNormalizeArguments` should merge `options` & `defaults`\nexports.preNormalizeArguments = (options, defaults) => {\n    var _a, _b;\n    // `options.headers`\n    if (is_1.default.undefined(options.headers)) {\n        options.headers = {};\n    }\n    else {\n        options.headers = lowercaseKeys(options.headers);\n    }\n    for (const [key, value] of Object.entries(options.headers)) {\n        if (is_1.default.null_(value)) {\n            throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n        }\n    }\n    // `options.prefixUrl`\n    if (is_1.default.urlInstance(options.prefixUrl) || is_1.default.string(options.prefixUrl)) {\n        options.prefixUrl = options.prefixUrl.toString();\n        if (options.prefixUrl.length !== 0 && !options.prefixUrl.endsWith('/')) {\n            options.prefixUrl += '/';\n        }\n    }\n    else {\n        options.prefixUrl = defaults ? defaults.prefixUrl : '';\n    }\n    // `options.hooks`\n    if (is_1.default.undefined(options.hooks)) {\n        options.hooks = {};\n    }\n    if (is_1.default.object(options.hooks)) {\n        for (const event of known_hook_events_1.default) {\n            if (Reflect.has(options.hooks, event)) {\n                if (!is_1.default.array(options.hooks[event])) {\n                    throw new TypeError(`Parameter \\`${event}\\` must be an Array, not ${is_1.default(options.hooks[event])}`);\n                }\n            }\n            else {\n                options.hooks[event] = [];\n            }\n        }\n    }\n    else {\n        throw new TypeError(`Parameter \\`hooks\\` must be an Object, not ${is_1.default(options.hooks)}`);\n    }\n    if (defaults) {\n        for (const event of known_hook_events_1.default) {\n            if (!(Reflect.has(options.hooks, event) && is_1.default.undefined(options.hooks[event]))) {\n                // @ts-ignore Union type array is not assignable to union array type\n                options.hooks[event] = [\n                    ...defaults.hooks[event],\n                    ...options.hooks[event]\n                ];\n            }\n        }\n    }\n    // `options.timeout`\n    if (is_1.default.number(options.timeout)) {\n        options.timeout = { request: options.timeout };\n    }\n    else if (!is_1.default.object(options.timeout)) {\n        options.timeout = {};\n    }\n    // `options.retry`\n    const { retry } = options;\n    if (defaults) {\n        options.retry = { ...defaults.retry };\n    }\n    else {\n        options.retry = {\n            calculateDelay: retryObject => retryObject.computedValue,\n            limit: 0,\n            methods: [],\n            statusCodes: [],\n            errorCodes: [],\n            maxRetryAfter: undefined\n        };\n    }\n    if (is_1.default.object(retry)) {\n        options.retry = {\n            ...options.retry,\n            ...retry\n        };\n    }\n    else if (is_1.default.number(retry)) {\n        options.retry.limit = retry;\n    }\n    if (options.retry.maxRetryAfter === undefined) {\n        // @ts-ignore We assign if it is undefined, so this IS correct\n        options.retry.maxRetryAfter = Math.min(...[options.timeout.request, options.timeout.connect].filter((n) => !is_1.default.nullOrUndefined(n)));\n    }\n    options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];\n    options.retry.statusCodes = [...new Set(options.retry.statusCodes)];\n    options.retry.errorCodes = [...new Set(options.retry.errorCodes)];\n    // `options.dnsCache`\n    if (options.dnsCache && !(options.dnsCache instanceof cacheable_lookup_1.default)) {\n        options.dnsCache = new cacheable_lookup_1.default({ cacheAdapter: options.dnsCache });\n    }\n    // `options.method`\n    if (is_1.default.string(options.method)) {\n        options.method = options.method.toUpperCase();\n    }\n    else {\n        options.method = (_b = (_a = defaults) === null || _a === void 0 ? void 0 : _a.method, (_b !== null && _b !== void 0 ? _b : 'GET'));\n    }\n    // Better memory management, so we don't have to generate a new object every time\n    if (options.cache) {\n        options.cacheableRequest = new CacheableRequest(\n        // @ts-ignore Types broke on infer\n        (requestOptions, handler) => requestOptions.request(requestOptions, handler), options.cache);\n    }\n    // `options.cookieJar`\n    if (is_1.default.object(options.cookieJar)) {\n        let { setCookie, getCookieString } = options.cookieJar;\n        // Horrible `tough-cookie` check\n        if (setCookie.length === 4 && getCookieString.length === 0) {\n            if (!Reflect.has(setCookie, util_1.promisify.custom)) {\n                // @ts-ignore We check for non-promisified setCookie, so this IS correct\n                setCookie = util_1.promisify(setCookie.bind(options.cookieJar));\n                getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));\n            }\n        }\n        else if (setCookie.length !== 2) {\n            throw new TypeError('`options.cookieJar.setCookie` needs to be an async function with 2 arguments');\n        }\n        else if (getCookieString.length !== 1) {\n            throw new TypeError('`options.cookieJar.getCookieString` needs to be an async function with 1 argument');\n        }\n        options.cookieJar = { setCookie, getCookieString };\n    }\n    // `options.encoding`\n    if (is_1.default.null_(options.encoding)) {\n        throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');\n    }\n    // `options.maxRedirects`\n    if (!Reflect.has(options, 'maxRedirects') && !(defaults && Reflect.has(defaults, 'maxRedirects'))) {\n        options.maxRedirects = 0;\n    }\n    return options;\n};\nexports.mergeOptions = (...sources) => {\n    const mergedOptions = exports.preNormalizeArguments({});\n    // Non enumerable properties shall not be merged\n    const properties = {};\n    for (const source of sources) {\n        merge_1.default(mergedOptions, exports.preNormalizeArguments(merge_1.default({}, source), mergedOptions));\n        for (const name of nonEnumerableProperties) {\n            if (!Reflect.has(source, name)) {\n                continue;\n            }\n            properties[name] = {\n                writable: true,\n                configurable: true,\n                enumerable: false,\n                value: source[name]\n            };\n        }\n    }\n    Object.defineProperties(mergedOptions, properties);\n    return mergedOptions;\n};\nexports.normalizeArguments = (url, options, defaults) => {\n    var _a, _b, _c, _d;\n    // Merge options\n    if (typeof url === 'undefined') {\n        throw new TypeError('Missing `url` argument');\n    }\n    if (typeof options === 'undefined') {\n        options = {};\n    }\n    if (is_1.default.urlInstance(url) || is_1.default.string(url)) {\n        // @ts-ignore URL is not URL\n        options.url = url;\n        options = exports.mergeOptions((_b = (_a = defaults) === null || _a === void 0 ? void 0 : _a.options, (_b !== null && _b !== void 0 ? _b : {})), options);\n    }\n    else {\n        if (Reflect.has(url, 'resolve')) {\n            throw new Error('The legacy `url.Url` is deprecated. Use `URL` instead.');\n        }\n        options = exports.mergeOptions((_d = (_c = defaults) === null || _c === void 0 ? void 0 : _c.options, (_d !== null && _d !== void 0 ? _d : {})), url, options);\n    }\n    // Normalize URL\n    // TODO: drop `optionsToUrl` in Got 12\n    if (is_1.default.string(options.url)) {\n        options.url = options.prefixUrl + options.url;\n        options.url = options.url.replace(/^unix:/, 'http://$&');\n        if (options.searchParams || options.search) {\n            options.url = options.url.split('?')[0];\n        }\n        options.url = options_to_url_1.default({\n            origin: options.url,\n            ...options\n        });\n    }\n    else if (!is_1.default.urlInstance(options.url)) {\n        options.url = options_to_url_1.default({ origin: options.prefixUrl, ...options });\n    }\n    const normalizedOptions = options;\n    // Make it possible to change `options.prefixUrl`\n    let prefixUrl = options.prefixUrl;\n    Object.defineProperty(normalizedOptions, 'prefixUrl', {\n        set: (value) => {\n            if (!normalizedOptions.url.href.startsWith(value)) {\n                throw new Error(`Cannot change \\`prefixUrl\\` from ${prefixUrl} to ${value}: ${normalizedOptions.url.href}`);\n            }\n            normalizedOptions.url = new url_1.URL(value + normalizedOptions.url.href.slice(prefixUrl.length));\n            prefixUrl = value;\n        },\n        get: () => prefixUrl\n    });\n    // Make it possible to remove default headers\n    for (const [key, value] of Object.entries(normalizedOptions.headers)) {\n        if (is_1.default.undefined(value)) {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete normalizedOptions.headers[key];\n        }\n    }\n    for (const hook of normalizedOptions.hooks.init) {\n        const result = hook(normalizedOptions);\n        if (is_1.default.promise(result)) {\n            throw new TypeError('The `init` hook must be a synchronous function');\n        }\n    }\n    return normalizedOptions;\n};\nconst withoutBody = new Set(['GET', 'HEAD']);\nexports.normalizeRequestArguments = async (options) => {\n    var _a, _b, _c;\n    options = exports.mergeOptions(options);\n    // Serialize body\n    const { headers } = options;\n    const noContentType = is_1.default.undefined(headers['content-type']);\n    {\n        // TODO: these checks should be moved to `preNormalizeArguments`\n        const isForm = !is_1.default.undefined(options.form);\n        const isJSON = !is_1.default.undefined(options.json);\n        const isBody = !is_1.default.undefined(options.body);\n        if ((isBody || isForm || isJSON) && withoutBody.has(options.method)) {\n            throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n        }\n        if ([isBody, isForm, isJSON].filter(isTrue => isTrue).length > 1) {\n            throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');\n        }\n        if (isBody &&\n            !is_1.default.nodeStream(options.body) &&\n            !is_1.default.string(options.body) &&\n            !is_1.default.buffer(options.body) &&\n            !(is_1.default.object(options.body) && is_form_data_1.default(options.body))) {\n            throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');\n        }\n        if (isForm && !is_1.default.object(options.form)) {\n            throw new TypeError('The `form` option must be an Object');\n        }\n    }\n    if (options.body) {\n        // Special case for https://github.com/form-data/form-data\n        if (is_1.default.object(options.body) && is_form_data_1.default(options.body) && noContentType) {\n            headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n        }\n    }\n    else if (options.form) {\n        if (noContentType) {\n            headers['content-type'] = 'application/x-www-form-urlencoded';\n        }\n        options.body = (new url_1.URLSearchParams(options.form)).toString();\n    }\n    else if (options.json) {\n        if (noContentType) {\n            headers['content-type'] = 'application/json';\n        }\n        options.body = JSON.stringify(options.json);\n    }\n    const uploadBodySize = await get_body_size_1.default(options);\n    if (!is_1.default.nodeStream(options.body)) {\n        options.body = toReadableStream(options.body);\n    }\n    // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD send a Content-Length in a request message when\n    // no Transfer-Encoding is sent and the request method defines a meaning\n    // for an enclosed payload body.  For example, a Content-Length header\n    // field is normally sent in a POST request even when the value is 0\n    // (indicating an empty payload body).  A user agent SHOULD NOT send a\n    // Content-Length header field when the request message does not contain\n    // a payload body and the method semantics do not anticipate such a\n    // body.\n    if (noContentType && is_1.default.undefined(headers['transfer-encoding'])) {\n        if ((options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') &&\n            !is_1.default.undefined(uploadBodySize)) {\n            // @ts-ignore We assign if it is undefined, so this IS correct\n            headers['content-length'] = String(uploadBodySize);\n        }\n    }\n    if (!options.isStream && options.responseType === 'json' && is_1.default.undefined(headers.accept)) {\n        headers.accept = 'application/json';\n    }\n    if (options.decompress && is_1.default.undefined(headers['accept-encoding'])) {\n        headers['accept-encoding'] = supports_brotli_1.default ? 'gzip, deflate, br' : 'gzip, deflate';\n    }\n    // Validate URL\n    if (options.url.protocol !== 'http:' && options.url.protocol !== 'https:') {\n        throw new errors_1.UnsupportedProtocolError(options);\n    }\n    decodeURI(options.url.toString());\n    // Normalize request function\n    if (!is_1.default.function_(options.request)) {\n        options.request = options.url.protocol === 'https:' ? https.request : http.request;\n    }\n    // UNIX sockets\n    if (options.url.hostname === 'unix') {\n        const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(options.url.pathname);\n        if ((_a = matches) === null || _a === void 0 ? void 0 : _a.groups) {\n            const { socketPath, path } = matches.groups;\n            options = {\n                ...options,\n                socketPath,\n                path,\n                host: ''\n            };\n        }\n    }\n    if (isAgentByProtocol(options.agent)) {\n        options.agent = (_b = options.agent[options.url.protocol.slice(0, -1)], (_b !== null && _b !== void 0 ? _b : options.agent));\n    }\n    if (options.dnsCache) {\n        options.lookup = options.dnsCache.lookup;\n    }\n    /* istanbul ignore next: electron.net is broken */\n    // No point in typing process.versions correctly, as\n    // `process.version.electron` is used only once, right here.\n    if (options.useElectronNet && process.versions.electron) {\n        const electron = dynamic_require_1.default(module, 'electron'); // Trick webpack\n        options.request = (_c = electron.net.request, (_c !== null && _c !== void 0 ? _c : electron.remote.net.request));\n    }\n    // Got's `timeout` is an object, http's `timeout` is a number, so they're not compatible.\n    delete options.timeout;\n    // Set cookies\n    if (options.cookieJar) {\n        const cookieString = await options.cookieJar.getCookieString(options.url.toString());\n        if (is_1.default.nonEmptyString(cookieString)) {\n            options.headers.cookie = cookieString;\n        }\n        else {\n            delete options.headers.cookie;\n        }\n    }\n    // `http-cache-semantics` checks this\n    delete options.url;\n    return options;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst knownHookEvents = [\n    'beforeError',\n    'init',\n    'beforeRequest',\n    'beforeRedirect',\n    'beforeRetry',\n    'afterResponse'\n];\nexports.default = knownHookEvents;\n","\n/* istanbul ignore file: used for webpack */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (moduleObject, moduleId) => moduleObject.require(moduleId);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = require(\"fs\");\nconst util_1 = require(\"util\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst is_form_data_1 = require(\"./is-form-data\");\nconst statAsync = util_1.promisify(fs_1.stat);\nexports.default = async (options) => {\n    const { body, headers, isStream } = options;\n    if (headers && 'content-length' in headers) {\n        return Number(headers['content-length']);\n    }\n    if (!body && !isStream) {\n        return 0;\n    }\n    if (is_1.default.string(body)) {\n        return Buffer.byteLength(body);\n    }\n    if (is_1.default.buffer(body)) {\n        return body.length;\n    }\n    if (is_form_data_1.default(body)) {\n        return util_1.promisify(body.getLength.bind(body))();\n    }\n    if (body instanceof fs_1.ReadStream) {\n        const { size } = await statAsync(body.path);\n        return size;\n    }\n    return undefined;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst is_1 = require(\"@sindresorhus/is\");\nexports.default = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nconst is_1 = require(\"@sindresorhus/is\");\nfunction merge(target, ...sources) {\n    for (const source of sources) {\n        for (const [key, sourceValue] of Object.entries(source)) {\n            const targetValue = target[key];\n            if (is_1.default.urlInstance(targetValue) && is_1.default.string(sourceValue)) {\n                // @ts-ignore TS doesn't recognise Target accepts string keys\n                target[key] = new url_1.URL(sourceValue, targetValue);\n            }\n            else if (is_1.default.plainObject(sourceValue)) {\n                if (is_1.default.plainObject(targetValue)) {\n                    // @ts-ignore TS doesn't recognise Target accepts string keys\n                    target[key] = merge({}, targetValue, sourceValue);\n                }\n                else {\n                    // @ts-ignore TS doesn't recognise Target accepts string keys\n                    target[key] = merge({}, sourceValue);\n                }\n            }\n            else if (is_1.default.array(sourceValue)) {\n                // @ts-ignore TS doesn't recognise Target accepts string keys\n                target[key] = sourceValue.slice();\n            }\n            else {\n                // @ts-ignore TS doesn't recognise Target accepts string keys\n                target[key] = sourceValue;\n            }\n        }\n    }\n    return target;\n}\nexports.default = merge;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nfunction validateSearchParams(searchParams) {\n    for (const value of Object.values(searchParams)) {\n        if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean' && value !== null) {\n            throw new TypeError(`The \\`searchParams\\` value '${String(value)}' must be a string, number, boolean or null`);\n        }\n    }\n}\nconst keys = [\n    'protocol',\n    'username',\n    'password',\n    'host',\n    'hostname',\n    'port',\n    'pathname',\n    'search',\n    'hash'\n];\nexports.default = (options) => {\n    var _a, _b;\n    let origin;\n    if (options.path) {\n        if (options.pathname) {\n            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');\n        }\n        if (options.search) {\n            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');\n        }\n        if (options.searchParams) {\n            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');\n        }\n    }\n    if (Reflect.has(options, 'auth')) {\n        throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');\n    }\n    if (options.search && options.searchParams) {\n        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');\n    }\n    if (options.href) {\n        return new url_1.URL(options.href);\n    }\n    if (options.origin) {\n        origin = options.origin;\n    }\n    else {\n        if (!options.protocol) {\n            throw new TypeError('No URL protocol specified');\n        }\n        origin = `${options.protocol}//${_b = (_a = options.hostname, (_a !== null && _a !== void 0 ? _a : options.host)), (_b !== null && _b !== void 0 ? _b : '')}`;\n    }\n    const url = new url_1.URL(origin);\n    if (options.path) {\n        const searchIndex = options.path.indexOf('?');\n        if (searchIndex === -1) {\n            options.pathname = options.path;\n        }\n        else {\n            options.pathname = options.path.slice(0, searchIndex);\n            options.search = options.path.slice(searchIndex + 1);\n        }\n    }\n    if (Reflect.has(options, 'path')) {\n        delete options.path;\n    }\n    for (const key of keys) {\n        if (Reflect.has(options, key)) {\n            url[key] = options[key].toString();\n        }\n    }\n    if (options.searchParams) {\n        if (typeof options.searchParams !== 'string' && !(options.searchParams instanceof url_1.URLSearchParams)) {\n            validateSearchParams(options.searchParams);\n        }\n        (new url_1.URLSearchParams(options.searchParams)).forEach((value, key) => {\n            url.searchParams.append(key, value);\n        });\n    }\n    return url;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst zlib = require(\"zlib\");\nexports.default = typeof zlib.createBrotliDecompress === 'function';\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CacheableRequest = require(\"cacheable-request\");\nconst EventEmitter = require(\"events\");\nconst http = require(\"http\");\nconst stream = require(\"stream\");\nconst url_1 = require(\"url\");\nconst util_1 = require(\"util\");\nconst is_1 = require(\"@sindresorhus/is\");\nconst http_timer_1 = require(\"@szmarczak/http-timer\");\nconst calculate_retry_delay_1 = require(\"./calculate-retry-delay\");\nconst errors_1 = require(\"./errors\");\nconst get_response_1 = require(\"./get-response\");\nconst normalize_arguments_1 = require(\"./normalize-arguments\");\nconst progress_1 = require(\"./progress\");\nconst timed_out_1 = require(\"./utils/timed-out\");\nconst url_to_options_1 = require(\"./utils/url-to-options\");\nconst setImmediateAsync = async () => new Promise(resolve => setImmediate(resolve));\nconst pipeline = util_1.promisify(stream.pipeline);\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nexports.default = (options) => {\n    const emitter = new EventEmitter();\n    const requestURL = options.url.toString();\n    const redirects = [];\n    let retryCount = 0;\n    let currentRequest;\n    // `request.aborted` is a boolean since v11.0.0: https://github.com/nodejs/node/commit/4b00c4fafaa2ae8c41c1f78823c0feb810ae4723#diff-e3bc37430eb078ccbafe3aa3b570c91a\n    const isAborted = () => typeof currentRequest.aborted === 'number' || currentRequest.aborted;\n    const emitError = async (error) => {\n        try {\n            for (const hook of options.hooks.beforeError) {\n                // eslint-disable-next-line no-await-in-loop\n                error = await hook(error);\n            }\n            emitter.emit('error', error);\n        }\n        catch (error_) {\n            emitter.emit('error', error_);\n        }\n    };\n    const get = async () => {\n        let httpOptions = await normalize_arguments_1.normalizeRequestArguments(options);\n        const handleResponse = async (response) => {\n            var _a;\n            try {\n                /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n                if (options.useElectronNet) {\n                    response = new Proxy(response, {\n                        get: (target, name) => {\n                            if (name === 'trailers' || name === 'rawTrailers') {\n                                return [];\n                            }\n                            const value = target[name];\n                            return is_1.default.function_(value) ? value.bind(target) : value;\n                        }\n                    });\n                }\n                const typedResponse = response;\n                const { statusCode } = typedResponse;\n                typedResponse.statusMessage = is_1.default.nonEmptyString(typedResponse.statusMessage) ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n                typedResponse.url = options.url.toString();\n                typedResponse.requestUrl = requestURL;\n                typedResponse.retryCount = retryCount;\n                typedResponse.redirectUrls = redirects;\n                typedResponse.request = { options };\n                typedResponse.isFromCache = (_a = typedResponse.fromCache, (_a !== null && _a !== void 0 ? _a : false));\n                delete typedResponse.fromCache;\n                if (!typedResponse.isFromCache) {\n                    // @ts-ignore Node.js typings haven't been updated yet\n                    typedResponse.ip = response.socket.remoteAddress;\n                }\n                const rawCookies = typedResponse.headers['set-cookie'];\n                if (Reflect.has(options, 'cookieJar') && rawCookies) {\n                    let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, typedResponse.url));\n                    if (options.ignoreInvalidCookies) {\n                        promises = promises.map(async (p) => p.catch(() => { }));\n                    }\n                    await Promise.all(promises);\n                }\n                if (options.followRedirect && Reflect.has(typedResponse.headers, 'location') && redirectCodes.has(statusCode)) {\n                    typedResponse.resume(); // We're being redirected, we don't care about the response.\n                    if (statusCode === 303 || options.methodRewriting === false) {\n                        if (options.method !== 'GET' && options.method !== 'HEAD') {\n                            // Server responded with \"see other\", indicating that the resource exists at another location,\n                            // and the client should request it from that location via GET or HEAD.\n                            options.method = 'GET';\n                        }\n                        delete options.body;\n                        delete options.json;\n                        delete options.form;\n                    }\n                    if (redirects.length >= options.maxRedirects) {\n                        throw new errors_1.MaxRedirectsError(typedResponse, options.maxRedirects, options);\n                    }\n                    // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n                    const redirectBuffer = Buffer.from(typedResponse.headers.location, 'binary').toString();\n                    const redirectURL = new url_1.URL(redirectBuffer, options.url);\n                    // Redirecting to a different site, clear cookies.\n                    if (redirectURL.hostname !== options.url.hostname) {\n                        delete options.headers.cookie;\n                    }\n                    redirects.push(redirectURL.toString());\n                    options.url = redirectURL;\n                    for (const hook of options.hooks.beforeRedirect) {\n                        // eslint-disable-next-line no-await-in-loop\n                        await hook(options, typedResponse);\n                    }\n                    emitter.emit('redirect', response, options);\n                    await get();\n                    return;\n                }\n                try {\n                    await get_response_1.default(typedResponse, options, emitter);\n                }\n                catch (error) {\n                    // Don't throw `Premature close` if the request has been aborted\n                    if (!(isAborted() && error.message === 'Premature close')) {\n                        throw error;\n                    }\n                }\n            }\n            catch (error) {\n                emitError(error);\n            }\n        };\n        const handleRequest = async (request) => {\n            let isPiped = false;\n            let isFinished = false;\n            // `request.finished` doesn't indicate whether this has been emitted or not\n            request.once('finish', () => {\n                isFinished = true;\n            });\n            currentRequest = request;\n            const onError = (error) => {\n                if (error instanceof timed_out_1.TimeoutError) {\n                    error = new errors_1.TimeoutError(error, request.timings, options);\n                }\n                else {\n                    error = new errors_1.RequestError(error, options);\n                }\n                if (!emitter.retry(error)) {\n                    emitError(error);\n                }\n            };\n            request.on('error', error => {\n                if (isPiped) {\n                    // Check if it's caught by `stream.pipeline(...)`\n                    if (!isFinished) {\n                        return;\n                    }\n                    // We need to let `TimedOutTimeoutError` through, because `stream.pipeline()` aborts the request automatically.\n                    if (isAborted() && !(error instanceof timed_out_1.TimeoutError)) {\n                        return;\n                    }\n                }\n                onError(error);\n            });\n            try {\n                http_timer_1.default(request);\n                timed_out_1.default(request, options.timeout, options.url);\n                emitter.emit('request', request);\n                const uploadStream = progress_1.createProgressStream('uploadProgress', emitter, httpOptions.headers['content-length']);\n                isPiped = true;\n                await pipeline(httpOptions.body, uploadStream, request);\n                request.emit('upload-complete');\n            }\n            catch (error) {\n                if (isAborted() && error.message === 'Premature close') {\n                    // The request was aborted on purpose\n                    return;\n                }\n                onError(error);\n            }\n        };\n        if (options.cache) {\n            // `cacheable-request` doesn't support Node 10 API, fallback.\n            httpOptions = {\n                ...httpOptions,\n                ...url_to_options_1.default(options.url)\n            };\n            // @ts-ignore ResponseLike missing socket field, should be fixed upstream\n            const cacheRequest = options.cacheableRequest(httpOptions, handleResponse);\n            cacheRequest.once('error', (error) => {\n                if (error instanceof CacheableRequest.RequestError) {\n                    emitError(new errors_1.RequestError(error, options));\n                }\n                else {\n                    emitError(new errors_1.CacheError(error, options));\n                }\n            });\n            cacheRequest.once('request', handleRequest);\n        }\n        else {\n            // Catches errors thrown by calling `requestFn()`\n            try {\n                // @ts-ignore ResponseObject does not equal IncomingMessage\n                handleRequest(httpOptions.request(options.url, httpOptions, handleResponse));\n            }\n            catch (error) {\n                emitError(new errors_1.RequestError(error, options));\n            }\n        }\n    };\n    emitter.retry = error => {\n        let backoff;\n        retryCount++;\n        try {\n            backoff = options.retry.calculateDelay({\n                attemptCount: retryCount,\n                retryOptions: options.retry,\n                error,\n                computedValue: calculate_retry_delay_1.default({\n                    attemptCount: retryCount,\n                    retryOptions: options.retry,\n                    error,\n                    computedValue: 0\n                })\n            });\n        }\n        catch (error_) {\n            emitError(error_);\n            return false;\n        }\n        if (backoff) {\n            const retry = async (options) => {\n                try {\n                    for (const hook of options.hooks.beforeRetry) {\n                        // eslint-disable-next-line no-await-in-loop\n                        await hook(options, error, retryCount);\n                    }\n                    await get();\n                }\n                catch (error_) {\n                    emitError(error_);\n                }\n            };\n            setTimeout(retry, backoff, { ...options, forceRefresh: true });\n            return true;\n        }\n        return false;\n    };\n    emitter.abort = () => {\n        emitter.prependListener('request', (request) => {\n            request.abort();\n        });\n        if (currentRequest) {\n            currentRequest.abort();\n        }\n    };\n    (async () => {\n        // Promises are executed immediately.\n        // If there were no `setImmediate` here,\n        // `promise.json()` would have no effect\n        // as the request would be sent already.\n        await setImmediateAsync();\n        try {\n            for (const hook of options.hooks.beforeRequest) {\n                // eslint-disable-next-line no-await-in-loop\n                await hook(options);\n            }\n            await get();\n        }\n        catch (error) {\n            emitError(error);\n        }\n    })();\n    return emitter;\n};\nexports.proxyEvents = (proxy, emitter) => {\n    const events = [\n        'request',\n        'redirect',\n        'uploadProgress',\n        'downloadProgress'\n    ];\n    for (const event of events) {\n        emitter.on(event, (...args) => {\n            proxy.emit(event, ...args);\n        });\n    }\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst is_1 = require(\"@sindresorhus/is\");\nconst errors_1 = require(\"./errors\");\nconst retryAfterStatusCodes = new Set([413, 429, 503]);\nconst isErrorWithResponse = (error) => (error instanceof errors_1.HTTPError || error instanceof errors_1.ParseError || error instanceof errors_1.MaxRedirectsError);\nconst calculateRetryDelay = ({ attemptCount, retryOptions, error }) => {\n    if (attemptCount > retryOptions.limit) {\n        return 0;\n    }\n    const hasMethod = retryOptions.methods.includes(error.options.method);\n    const hasErrorCode = Reflect.has(error, 'code') && retryOptions.errorCodes.includes(error.code);\n    const hasStatusCode = isErrorWithResponse(error) && retryOptions.statusCodes.includes(error.response.statusCode);\n    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {\n        return 0;\n    }\n    if (isErrorWithResponse(error)) {\n        const { response } = error;\n        if (response && Reflect.has(response.headers, 'retry-after') && retryAfterStatusCodes.has(response.statusCode)) {\n            let after = Number(response.headers['retry-after']);\n            if (is_1.default.nan(after)) {\n                after = Date.parse(response.headers['retry-after']) - Date.now();\n            }\n            else {\n                after *= 1000;\n            }\n            if (after > retryOptions.maxRetryAfter) {\n                return 0;\n            }\n            return after;\n        }\n        if (response.statusCode === 413) {\n            return 0;\n        }\n    }\n    const noise = Math.random() * 100;\n    return ((2 ** (attemptCount - 1)) * 1000) + noise;\n};\nexports.default = calculateRetryDelay;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst decompressResponse = require(\"decompress-response\");\nconst mimicResponse = require(\"mimic-response\");\nconst stream = require(\"stream\");\nconst util_1 = require(\"util\");\nconst progress_1 = require(\"./progress\");\nconst pipeline = util_1.promisify(stream.pipeline);\nexports.default = async (response, options, emitter) => {\n    var _a;\n    const downloadBodySize = Number(response.headers['content-length']) || undefined;\n    const progressStream = progress_1.createProgressStream('downloadProgress', emitter, downloadBodySize);\n    mimicResponse(response, progressStream);\n    const newResponse = (options.decompress &&\n        options.method !== 'HEAD' ? decompressResponse(progressStream) : progressStream);\n    if (!options.decompress && ['gzip', 'deflate', 'br'].includes((_a = response.headers['content-encoding'], (_a !== null && _a !== void 0 ? _a : '')))) {\n        options.responseType = 'buffer';\n    }\n    emitter.emit('response', newResponse);\n    return pipeline(response, progressStream);\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stream_1 = require(\"stream\");\nconst is_1 = require(\"@sindresorhus/is\");\nfunction createProgressStream(name, emitter, totalBytes) {\n    let transformedBytes = 0;\n    if (is_1.default.string(totalBytes)) {\n        totalBytes = Number(totalBytes);\n    }\n    const progressStream = new stream_1.Transform({\n        transform(chunk, _encoding, callback) {\n            transformedBytes += chunk.length;\n            const percent = totalBytes ? transformedBytes / totalBytes : 0;\n            // Let `flush()` be responsible for emitting the last event\n            if (percent < 1) {\n                emitter.emit(name, {\n                    percent,\n                    transferred: transformedBytes,\n                    total: totalBytes\n                });\n            }\n            callback(undefined, chunk);\n        },\n        flush(callback) {\n            emitter.emit(name, {\n                percent: 1,\n                transferred: transformedBytes,\n                total: totalBytes\n            });\n            callback();\n        }\n    });\n    emitter.emit(name, {\n        percent: 0,\n        transferred: 0,\n        total: totalBytes\n    });\n    return progressStream;\n}\nexports.createProgressStream = createProgressStream;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net = require(\"net\");\nconst unhandle_1 = require(\"./unhandle\");\nconst reentry = Symbol('reentry');\nconst noop = () => { };\nclass TimeoutError extends Error {\n    constructor(threshold, event) {\n        super(`Timeout awaiting '${event}' for ${threshold}ms`);\n        Object.defineProperty(this, \"event\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: event\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = 'TimeoutError';\n        this.code = 'ETIMEDOUT';\n    }\n}\nexports.TimeoutError = TimeoutError;\nexports.default = (request, delays, options) => {\n    if (Reflect.has(request, reentry)) {\n        return noop;\n    }\n    request[reentry] = true;\n    const cancelers = [];\n    const { once, unhandleAll } = unhandle_1.default();\n    const addTimeout = (delay, callback, ...args) => {\n        var _a, _b;\n        // Event loop order is timers, poll, immediates.\n        // The timed event may emit during the current tick poll phase, so\n        // defer calling the handler until the poll phase completes.\n        let immediate;\n        const timeout = setTimeout(() => {\n            var _a, _b;\n            // @ts-ignore https://github.com/microsoft/TypeScript/issues/26113\n            immediate = setImmediate(callback, delay, ...args);\n            (_b = (_a = immediate).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }, delay);\n        (_b = (_a = timeout).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        const cancel = () => {\n            clearTimeout(timeout);\n            clearImmediate(immediate);\n        };\n        cancelers.push(cancel);\n        return cancel;\n    };\n    const { host, hostname } = options;\n    const timeoutHandler = (delay, event) => {\n        if (request.socket) {\n            // @ts-ignore We do not want the `socket hang up` error\n            request.socket._hadError = true;\n        }\n        request.abort();\n        request.emit('error', new TimeoutError(delay, event));\n    };\n    const cancelTimeouts = () => {\n        for (const cancel of cancelers) {\n            cancel();\n        }\n        unhandleAll();\n    };\n    request.once('error', error => {\n        cancelTimeouts();\n        // Save original behavior\n        if (request.listenerCount('error') === 0) {\n            throw error;\n        }\n    });\n    request.once('abort', cancelTimeouts);\n    once(request, 'response', (response) => {\n        once(response, 'end', cancelTimeouts);\n    });\n    if (typeof delays.request !== 'undefined') {\n        addTimeout(delays.request, timeoutHandler, 'request');\n    }\n    if (typeof delays.socket !== 'undefined') {\n        const socketTimeoutHandler = () => {\n            timeoutHandler(delays.socket, 'socket');\n        };\n        request.setTimeout(delays.socket, socketTimeoutHandler);\n        // `request.setTimeout(0)` causes a memory leak.\n        // We can just remove the listener and forget about the timer - it's unreffed.\n        // See https://github.com/sindresorhus/got/issues/690\n        cancelers.push(() => {\n            request.removeListener('timeout', socketTimeoutHandler);\n        });\n    }\n    once(request, 'socket', (socket) => {\n        var _a;\n        // @ts-ignore Node typings doesn't have this property\n        const { socketPath } = request;\n        /* istanbul ignore next: hard to test */\n        if (socket.connecting) {\n            const hasPath = Boolean((socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = (hostname !== null && hostname !== void 0 ? hostname : host), (_a !== null && _a !== void 0 ? _a : ''))) !== 0));\n            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {\n                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n                once(socket, 'lookup', cancelTimeout);\n            }\n            if (typeof delays.connect !== 'undefined') {\n                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n                if (hasPath) {\n                    once(socket, 'connect', timeConnect());\n                }\n                else {\n                    once(socket, 'lookup', (error) => {\n                        if (error === null) {\n                            once(socket, 'connect', timeConnect());\n                        }\n                    });\n                }\n            }\n            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {\n                once(socket, 'connect', () => {\n                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n                    once(socket, 'secureConnect', cancelTimeout);\n                });\n            }\n        }\n        if (typeof delays.send !== 'undefined') {\n            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n            /* istanbul ignore next: hard to test */\n            if (socket.connecting) {\n                once(socket, 'connect', () => {\n                    once(request, 'upload-complete', timeRequest());\n                });\n            }\n            else {\n                once(request, 'upload-complete', timeRequest());\n            }\n        }\n    });\n    if (typeof delays.response !== 'undefined') {\n        once(request, 'upload-complete', () => {\n            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n            once(request, 'response', cancelTimeout);\n        });\n    }\n    return cancelTimeouts;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// When attaching listeners, it's very easy to forget about them.\n// Especially if you do error handling and set timeouts.\n// So instead of checking if it's proper to throw an error on every timeout ever,\n// use this simple tool which will remove all listeners you have attached.\nexports.default = () => {\n    const handlers = [];\n    return {\n        once(origin, event, fn) {\n            origin.once(event, fn);\n            handlers.push({ origin, event, fn });\n        },\n        unhandleAll() {\n            for (const handler of handlers) {\n                const { origin, event, fn } = handler;\n                origin.removeListener(event, fn);\n            }\n            handlers.length = 0;\n        }\n    };\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst is_1 = require(\"@sindresorhus/is\");\nexports.default = (url) => {\n    // Cast to URL\n    url = url;\n    const options = {\n        protocol: url.protocol,\n        hostname: url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n        host: url.host,\n        hash: url.hash,\n        search: url.search,\n        pathname: url.pathname,\n        href: url.href,\n        path: is_1.default.null_(url.search) ? url.pathname : `${url.pathname}${url.search}`\n    };\n    if (is_1.default.string(url.port) && url.port.length !== 0) {\n        options.port = Number(url.port);\n    }\n    if (url.username || url.password) {\n        options.auth = `${url.username}:${url.password}`;\n    }\n    return options;\n};\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst duplexer3 = require(\"duplexer3\");\nconst stream = require(\"stream\");\nconst http_1 = require(\"http\");\nconst stream_1 = require(\"stream\");\nconst errors_1 = require(\"./errors\");\nconst request_as_event_emitter_1 = require(\"./request-as-event-emitter\");\nclass ProxyStream extends stream_1.Duplex {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"isFromCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n}\nexports.ProxyStream = ProxyStream;\nfunction asStream(options) {\n    const input = new stream_1.PassThrough();\n    const output = new stream_1.PassThrough();\n    const proxy = duplexer3(input, output);\n    const piped = new Set();\n    let isFinished = false;\n    options.retry.calculateDelay = () => 0;\n    if (options.body || options.json || options.form) {\n        proxy.write = () => {\n            proxy.destroy();\n            throw new Error('Got\\'s stream is not writable when the `body`, `json` or `form` option is used');\n        };\n    }\n    else if (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') {\n        options.body = input;\n    }\n    else {\n        proxy.write = () => {\n            proxy.destroy();\n            throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n        };\n    }\n    const emitter = request_as_event_emitter_1.default(options);\n    const emitError = async (error) => {\n        try {\n            for (const hook of options.hooks.beforeError) {\n                // eslint-disable-next-line no-await-in-loop\n                error = await hook(error);\n            }\n            proxy.emit('error', error);\n        }\n        catch (error_) {\n            proxy.emit('error', error_);\n        }\n    };\n    // Cancels the request\n    proxy._destroy = (error, callback) => {\n        callback(error);\n        emitter.abort();\n    };\n    emitter.on('response', (response) => {\n        const { statusCode, isFromCache } = response;\n        proxy.isFromCache = isFromCache;\n        if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n            emitError(new errors_1.HTTPError(response, options));\n            return;\n        }\n        {\n            const read = proxy._read;\n            proxy._read = (...args) => {\n                isFinished = true;\n                proxy._read = read;\n                return read.apply(proxy, args);\n            };\n        }\n        if (options.encoding) {\n            proxy.setEncoding(options.encoding);\n        }\n        stream.pipeline(response, output, error => {\n            if (error && error.message !== 'Premature close') {\n                emitError(new errors_1.ReadError(error, options));\n            }\n        });\n        for (const destination of piped) {\n            if (destination.headersSent) {\n                continue;\n            }\n            for (const [key, value] of Object.entries(response.headers)) {\n                // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n                // It's not possible to decompress already decompressed data, is it?\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = response.statusCode;\n        }\n        proxy.emit('response', response);\n    });\n    request_as_event_emitter_1.proxyEvents(proxy, emitter);\n    emitter.on('error', (error) => proxy.emit('error', error));\n    const pipe = proxy.pipe.bind(proxy);\n    const unpipe = proxy.unpipe.bind(proxy);\n    proxy.pipe = (destination, options) => {\n        if (isFinished) {\n            throw new Error('Failed to pipe. The response has been emitted already.');\n        }\n        pipe(destination, options);\n        if (destination instanceof http_1.ServerResponse) {\n            piped.add(destination);\n        }\n        return destination;\n    };\n    proxy.unpipe = stream => {\n        piped.delete(stream);\n        return unpipe(stream);\n    };\n    proxy.on('pipe', source => {\n        if (source instanceof http_1.IncomingMessage) {\n            options.headers = {\n                ...source.headers,\n                ...options.headers\n            };\n        }\n    });\n    proxy.isFromCache = undefined;\n    return proxy;\n}\nexports.default = asStream;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst is_1 = require(\"@sindresorhus/is\");\nfunction deepFreeze(object) {\n    for (const value of Object.values(object)) {\n        if (is_1.default.plainObject(value) || is_1.default.array(value)) {\n            deepFreeze(value);\n        }\n    }\n    return Object.freeze(object);\n}\nexports.default = deepFreeze;\n"]}